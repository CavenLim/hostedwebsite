{"ast":null,"code":"/* eslint-disable consistent-return */\nimport { getWindow, getDocument } from 'ssr-window';\nimport $ from '../../utils/dom';\nimport { now, nextTick, bindModuleMethods } from '../../utils/utils';\nfunction isEventSupported() {\n  var document = getDocument();\n  var eventName = 'onwheel';\n  var isSupported = (eventName in document);\n  if (!isSupported) {\n    var element = document.createElement('div');\n    element.setAttribute(eventName, 'return;');\n    isSupported = typeof element[eventName] === 'function';\n  }\n  if (!isSupported && document.implementation && document.implementation.hasFeature &&\n  // always returns true in newer browsers as per the standard.\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\n  document.implementation.hasFeature('', '') !== true) {\n    // This is the only way to test support for the `wheel` event in IE9+.\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\n  }\n  return isSupported;\n}\nvar Mousewheel = {\n  lastScrollTime: now(),\n  lastEventBeforeSnap: undefined,\n  recentWheelEvents: [],\n  event: function event() {\n    var window = getWindow();\n    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\n    return isEventSupported() ? 'wheel' : 'mousewheel';\n  },\n  normalize: function normalize(e) {\n    // Reasonable defaults\n    var PIXEL_STEP = 10;\n    var LINE_HEIGHT = 40;\n    var PAGE_HEIGHT = 800;\n    var sX = 0;\n    var sY = 0; // spinX, spinY\n\n    var pX = 0;\n    var pY = 0; // pixelX, pixelY\n    // Legacy\n\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  },\n  handleMouseEnter: function handleMouseEnter() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  },\n  handleMouseLeave: function handleMouseLeave() {\n    var swiper = this;\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  },\n  handle: function handle(event) {\n    var e = event;\n    var disableParentSwiper = true;\n    var swiper = this;\n    if (!swiper.enabled) return;\n    var params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    var target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n    var delta = 0;\n    var rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    var data = Mousewheel.normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta; // Get the scroll positions\n\n    var positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode) {\n      // Register the new event in a variable which stores the relevant data\n      var newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      }; // Keep the most recent events\n\n      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          swiper.mousewheel.animateSlider(newEvent);\n        }\n      } else {\n        swiper.mousewheel.animateSlider(newEvent);\n      } // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n\n      if (swiper.mousewheel.releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      var _newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;\n      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        swiper.mousewheel.lastEventBeforeSnap = undefined;\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n        var position = swiper.getTranslate() + delta * params.sensitivity;\n        var wasBeginning = swiper.isBeginning;\n        var wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.freeModeSticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(swiper.mousewheel.timeout);\n          swiper.mousewheel.timeout = undefined;\n          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;\n          if (_recentWheelEvents.length >= 15) {\n            _recentWheelEvents.shift(); // only store the last N events\n          }\n          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;\n          var firstEvent = _recentWheelEvents[0];\n          _recentWheelEvents.push(_newEvent);\n          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            _recentWheelEvents.splice(0);\n          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            var snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n            _recentWheelEvents.splice(0);\n            swiper.mousewheel.timeout = nextTick(function () {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n          if (!swiper.mousewheel.timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            swiper.mousewheel.timeout = nextTick(function () {\n              var snapToThreshold = 0.5;\n              swiper.mousewheel.lastEventBeforeSnap = _newEvent;\n              _recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        } // Emit event\n\n        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay\n\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  },\n  animateSlider: function animateSlider(newEvent) {\n    var swiper = this;\n    var window = getWindow();\n    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    } // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n\n    if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    } // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        swiper.emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      swiper.emit('scroll', newEvent.raw);\n    } // If you got here is because an animation has been triggered so store the current time\n\n    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n    return false;\n  },\n  releaseScroll: function releaseScroll(newEvent) {\n    var swiper = this;\n    var params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  },\n  enable: function enable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n    if (!event) return false;\n    if (swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\n    target.on(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = true;\n    return true;\n  },\n  disable: function disable() {\n    var swiper = this;\n    var event = Mousewheel.event();\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);\n      return true;\n    }\n    if (!event) return false;\n    if (!swiper.mousewheel.enabled) return false;\n    var target = swiper.$el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n    target.off(event, swiper.mousewheel.handle);\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n};\nexport default {\n  name: 'mousewheel',\n  params: {\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  },\n  create: function create() {\n    var swiper = this;\n    bindModuleMethods(swiper, {\n      mousewheel: {\n        enabled: false,\n        lastScrollTime: now(),\n        lastEventBeforeSnap: undefined,\n        recentWheelEvents: [],\n        enable: Mousewheel.enable,\n        disable: Mousewheel.disable,\n        handle: Mousewheel.handle,\n        handleMouseEnter: Mousewheel.handleMouseEnter,\n        handleMouseLeave: Mousewheel.handleMouseLeave,\n        animateSlider: Mousewheel.animateSlider,\n        releaseScroll: Mousewheel.releaseScroll\n      }\n    });\n  },\n  on: {\n    init: function init(swiper) {\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n        swiper.mousewheel.disable();\n      }\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\n    },\n    destroy: function destroy(swiper) {\n      if (swiper.params.cssMode) {\n        swiper.mousewheel.enable();\n      }\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\n    }\n  }\n};","map":{"version":3,"names":["getWindow","getDocument","$","now","nextTick","bindModuleMethods","isEventSupported","document","eventName","isSupported","element","createElement","setAttribute","implementation","hasFeature","Mousewheel","lastScrollTime","lastEventBeforeSnap","undefined","recentWheelEvents","event","window","navigator","userAgent","indexOf","normalize","e","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","shiftKey","deltaMode","spinX","spinY","pixelX","pixelY","handleMouseEnter","swiper","enabled","mouseEntered","handleMouseLeave","handle","disableParentSwiper","params","mousewheel","cssMode","preventDefault","target","$el","eventsTarget","contains","releaseOnEdges","originalEvent","delta","rtlFactor","rtlTranslate","data","forceToAxis","isHorizontal","Math","abs","invert","positions","getTranslate","sensitivity","minTranslate","maxTranslate","loop","nested","stopPropagation","freeMode","newEvent","time","direction","sign","raw","length","shift","prevEvent","push","animateSlider","releaseScroll","_newEvent","ignoreWheelEvents","loopFix","position","wasBeginning","isBeginning","wasEnd","isEnd","setTransition","setTranslate","updateProgress","updateActiveIndex","updateSlidesClasses","freeModeSticky","clearTimeout","timeout","_recentWheelEvents","_prevEvent","firstEvent","splice","snapToThreshold","slideToClosest","speed","emit","autoplay","autoplayDisableOnInteraction","stop","returnValue","thresholdDelta","thresholdTime","animating","slideNext","slidePrev","Date","getTime","enable","wrapperEl","removeEventListener","on","disable","addEventListener","off","name","create","init","destroy"],"sources":["C:/Code Respositories/hostedwebsite/node_modules/swiper/esm/components/mousewheel/mousewheel.js"],"sourcesContent":["/* eslint-disable consistent-return */\r\nimport { getWindow, getDocument } from 'ssr-window';\r\nimport $ from '../../utils/dom';\r\nimport { now, nextTick, bindModuleMethods } from '../../utils/utils';\r\n\r\nfunction isEventSupported() {\r\n  var document = getDocument();\r\n  var eventName = 'onwheel';\r\n  var isSupported = (eventName in document);\r\n\r\n  if (!isSupported) {\r\n    var element = document.createElement('div');\r\n    element.setAttribute(eventName, 'return;');\r\n    isSupported = typeof element[eventName] === 'function';\r\n  }\r\n\r\n  if (!isSupported && document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.\r\n  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature\r\n  document.implementation.hasFeature('', '') !== true) {\r\n    // This is the only way to test support for the `wheel` event in IE9+.\r\n    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');\r\n  }\r\n\r\n  return isSupported;\r\n}\r\n\r\nvar Mousewheel = {\r\n  lastScrollTime: now(),\r\n  lastEventBeforeSnap: undefined,\r\n  recentWheelEvents: [],\r\n  event: function event() {\r\n    var window = getWindow();\r\n    if (window.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';\r\n    return isEventSupported() ? 'wheel' : 'mousewheel';\r\n  },\r\n  normalize: function normalize(e) {\r\n    // Reasonable defaults\r\n    var PIXEL_STEP = 10;\r\n    var LINE_HEIGHT = 40;\r\n    var PAGE_HEIGHT = 800;\r\n    var sX = 0;\r\n    var sY = 0; // spinX, spinY\r\n\r\n    var pX = 0;\r\n    var pY = 0; // pixelX, pixelY\r\n    // Legacy\r\n\r\n    if ('detail' in e) {\r\n      sY = e.detail;\r\n    }\r\n\r\n    if ('wheelDelta' in e) {\r\n      sY = -e.wheelDelta / 120;\r\n    }\r\n\r\n    if ('wheelDeltaY' in e) {\r\n      sY = -e.wheelDeltaY / 120;\r\n    }\r\n\r\n    if ('wheelDeltaX' in e) {\r\n      sX = -e.wheelDeltaX / 120;\r\n    } // side scrolling on FF with DOMMouseScroll\r\n\r\n\r\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\r\n      sX = sY;\r\n      sY = 0;\r\n    }\r\n\r\n    pX = sX * PIXEL_STEP;\r\n    pY = sY * PIXEL_STEP;\r\n\r\n    if ('deltaY' in e) {\r\n      pY = e.deltaY;\r\n    }\r\n\r\n    if ('deltaX' in e) {\r\n      pX = e.deltaX;\r\n    }\r\n\r\n    if (e.shiftKey && !pX) {\r\n      // if user scrolls with shift he wants horizontal scroll\r\n      pX = pY;\r\n      pY = 0;\r\n    }\r\n\r\n    if ((pX || pY) && e.deltaMode) {\r\n      if (e.deltaMode === 1) {\r\n        // delta in LINE units\r\n        pX *= LINE_HEIGHT;\r\n        pY *= LINE_HEIGHT;\r\n      } else {\r\n        // delta in PAGE units\r\n        pX *= PAGE_HEIGHT;\r\n        pY *= PAGE_HEIGHT;\r\n      }\r\n    } // Fall-back if spin cannot be determined\r\n\r\n\r\n    if (pX && !sX) {\r\n      sX = pX < 1 ? -1 : 1;\r\n    }\r\n\r\n    if (pY && !sY) {\r\n      sY = pY < 1 ? -1 : 1;\r\n    }\r\n\r\n    return {\r\n      spinX: sX,\r\n      spinY: sY,\r\n      pixelX: pX,\r\n      pixelY: pY\r\n    };\r\n  },\r\n  handleMouseEnter: function handleMouseEnter() {\r\n    var swiper = this;\r\n    if (!swiper.enabled) return;\r\n    swiper.mouseEntered = true;\r\n  },\r\n  handleMouseLeave: function handleMouseLeave() {\r\n    var swiper = this;\r\n    if (!swiper.enabled) return;\r\n    swiper.mouseEntered = false;\r\n  },\r\n  handle: function handle(event) {\r\n    var e = event;\r\n    var disableParentSwiper = true;\r\n    var swiper = this;\r\n    if (!swiper.enabled) return;\r\n    var params = swiper.params.mousewheel;\r\n\r\n    if (swiper.params.cssMode) {\r\n      e.preventDefault();\r\n    }\r\n\r\n    var target = swiper.$el;\r\n\r\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\r\n      target = $(swiper.params.mousewheel.eventsTarget);\r\n    }\r\n\r\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\r\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\r\n\r\n    var delta = 0;\r\n    var rtlFactor = swiper.rtlTranslate ? -1 : 1;\r\n    var data = Mousewheel.normalize(e);\r\n\r\n    if (params.forceToAxis) {\r\n      if (swiper.isHorizontal()) {\r\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\r\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\r\n    } else {\r\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\r\n    }\r\n\r\n    if (delta === 0) return true;\r\n    if (params.invert) delta = -delta; // Get the scroll positions\r\n\r\n    var positions = swiper.getTranslate() + delta * params.sensitivity;\r\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\r\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\r\n    //     the disableParentSwiper will be true.\r\n    // When loop is false:\r\n    //     if the scroll positions is not on edge,\r\n    //     then the disableParentSwiper will be true.\r\n    //     if the scroll on edge positions,\r\n    //     then the disableParentSwiper will be false.\r\n\r\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\r\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\r\n\r\n    if (!swiper.params.freeMode) {\r\n      // Register the new event in a variable which stores the relevant data\r\n      var newEvent = {\r\n        time: now(),\r\n        delta: Math.abs(delta),\r\n        direction: Math.sign(delta),\r\n        raw: event\r\n      }; // Keep the most recent events\r\n\r\n      var recentWheelEvents = swiper.mousewheel.recentWheelEvents;\r\n\r\n      if (recentWheelEvents.length >= 2) {\r\n        recentWheelEvents.shift(); // only store the last N events\r\n      }\r\n\r\n      var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\r\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\r\n      //   If direction has changed or\r\n      //   if the scroll is quicker than the previous one:\r\n      //     Animate the slider.\r\n      // Else (this is the first time the wheel is moved):\r\n      //     Animate the slider.\r\n\r\n      if (prevEvent) {\r\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\r\n          swiper.mousewheel.animateSlider(newEvent);\r\n        }\r\n      } else {\r\n        swiper.mousewheel.animateSlider(newEvent);\r\n      } // If it's time to release the scroll:\r\n      //   Return now so you don't hit the preventDefault.\r\n\r\n\r\n      if (swiper.mousewheel.releaseScroll(newEvent)) {\r\n        return true;\r\n      }\r\n    } else {\r\n      // Freemode or scrollContainer:\r\n      // If we recently snapped after a momentum scroll, then ignore wheel events\r\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\r\n      // or if it's a new scroll (larger delta or inverse sign as last event before\r\n      // an end-of-momentum snap).\r\n      var _newEvent = {\r\n        time: now(),\r\n        delta: Math.abs(delta),\r\n        direction: Math.sign(delta)\r\n      };\r\n      var lastEventBeforeSnap = swiper.mousewheel.lastEventBeforeSnap;\r\n      var ignoreWheelEvents = lastEventBeforeSnap && _newEvent.time < lastEventBeforeSnap.time + 500 && _newEvent.delta <= lastEventBeforeSnap.delta && _newEvent.direction === lastEventBeforeSnap.direction;\r\n\r\n      if (!ignoreWheelEvents) {\r\n        swiper.mousewheel.lastEventBeforeSnap = undefined;\r\n\r\n        if (swiper.params.loop) {\r\n          swiper.loopFix();\r\n        }\r\n\r\n        var position = swiper.getTranslate() + delta * params.sensitivity;\r\n        var wasBeginning = swiper.isBeginning;\r\n        var wasEnd = swiper.isEnd;\r\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\r\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\r\n        swiper.setTransition(0);\r\n        swiper.setTranslate(position);\r\n        swiper.updateProgress();\r\n        swiper.updateActiveIndex();\r\n        swiper.updateSlidesClasses();\r\n\r\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\r\n          swiper.updateSlidesClasses();\r\n        }\r\n\r\n        if (swiper.params.freeModeSticky) {\r\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\r\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\r\n          // 1. do all N events have decreasing or same (absolute value) delta?\r\n          // 2. did all N events arrive in the last M (M=500?) msecs?\r\n          // 3. does the earliest event have an (absolute value) delta that's\r\n          //    at least P (P=1?) larger than the most recent event's delta?\r\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\r\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\r\n          // Snap immediately and ignore remaining wheel events in this scroll.\r\n          // See comment above for \"remaining wheel events in this scroll\" determination.\r\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\r\n          clearTimeout(swiper.mousewheel.timeout);\r\n          swiper.mousewheel.timeout = undefined;\r\n          var _recentWheelEvents = swiper.mousewheel.recentWheelEvents;\r\n\r\n          if (_recentWheelEvents.length >= 15) {\r\n            _recentWheelEvents.shift(); // only store the last N events\r\n\r\n          }\r\n\r\n          var _prevEvent = _recentWheelEvents.length ? _recentWheelEvents[_recentWheelEvents.length - 1] : undefined;\r\n\r\n          var firstEvent = _recentWheelEvents[0];\r\n\r\n          _recentWheelEvents.push(_newEvent);\r\n\r\n          if (_prevEvent && (_newEvent.delta > _prevEvent.delta || _newEvent.direction !== _prevEvent.direction)) {\r\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\r\n            _recentWheelEvents.splice(0);\r\n          } else if (_recentWheelEvents.length >= 15 && _newEvent.time - firstEvent.time < 500 && firstEvent.delta - _newEvent.delta >= 1 && _newEvent.delta <= 6) {\r\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\r\n            // to wait for more events. Snap ASAP on the next tick.\r\n            // Also, because there's some remaining momentum we'll bias the snap in the\r\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\r\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\r\n            // if it's already scrolled more than 20% in the current direction, keep going.\r\n            var snapToThreshold = delta > 0 ? 0.8 : 0.2;\r\n            swiper.mousewheel.lastEventBeforeSnap = _newEvent;\r\n\r\n            _recentWheelEvents.splice(0);\r\n\r\n            swiper.mousewheel.timeout = nextTick(function () {\r\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\r\n            }, 0); // no delay; move on next tick\r\n          }\r\n\r\n          if (!swiper.mousewheel.timeout) {\r\n            // if we get here, then we haven't detected the end of a momentum scroll, so\r\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\r\n            // for 500ms.\r\n            swiper.mousewheel.timeout = nextTick(function () {\r\n              var snapToThreshold = 0.5;\r\n              swiper.mousewheel.lastEventBeforeSnap = _newEvent;\r\n\r\n              _recentWheelEvents.splice(0);\r\n\r\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\r\n            }, 500);\r\n          }\r\n        } // Emit event\r\n\r\n\r\n        if (!ignoreWheelEvents) swiper.emit('scroll', e); // Stop autoplay\r\n\r\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\r\n\r\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\r\n      }\r\n    }\r\n\r\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\r\n    return false;\r\n  },\r\n  animateSlider: function animateSlider(newEvent) {\r\n    var swiper = this;\r\n    var window = getWindow();\r\n\r\n    if (this.params.mousewheel.thresholdDelta && newEvent.delta < this.params.mousewheel.thresholdDelta) {\r\n      // Prevent if delta of wheel scroll delta is below configured threshold\r\n      return false;\r\n    }\r\n\r\n    if (this.params.mousewheel.thresholdTime && now() - swiper.mousewheel.lastScrollTime < this.params.mousewheel.thresholdTime) {\r\n      // Prevent if time between scrolls is below configured threshold\r\n      return false;\r\n    } // If the movement is NOT big enough and\r\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\r\n    //   Don't go any further (avoid insignificant scroll movement).\r\n\r\n\r\n    if (newEvent.delta >= 6 && now() - swiper.mousewheel.lastScrollTime < 60) {\r\n      // Return false as a default\r\n      return true;\r\n    } // If user is scrolling towards the end:\r\n    //   If the slider hasn't hit the latest slide or\r\n    //   if the slider is a loop and\r\n    //   if the slider isn't moving right now:\r\n    //     Go to next slide and\r\n    //     emit a scroll event.\r\n    // Else (the user is scrolling towards the beginning) and\r\n    // if the slider hasn't hit the first slide or\r\n    // if the slider is a loop and\r\n    // if the slider isn't moving right now:\r\n    //   Go to prev slide and\r\n    //   emit a scroll event.\r\n\r\n\r\n    if (newEvent.direction < 0) {\r\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\r\n        swiper.slideNext();\r\n        swiper.emit('scroll', newEvent.raw);\r\n      }\r\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\r\n      swiper.slidePrev();\r\n      swiper.emit('scroll', newEvent.raw);\r\n    } // If you got here is because an animation has been triggered so store the current time\r\n\r\n\r\n    swiper.mousewheel.lastScrollTime = new window.Date().getTime(); // Return false as a default\r\n\r\n    return false;\r\n  },\r\n  releaseScroll: function releaseScroll(newEvent) {\r\n    var swiper = this;\r\n    var params = swiper.params.mousewheel;\r\n\r\n    if (newEvent.direction < 0) {\r\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\r\n        // Return true to animate scroll on edges\r\n        return true;\r\n      }\r\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\r\n      // Return true to animate scroll on edges\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  },\r\n  enable: function enable() {\r\n    var swiper = this;\r\n    var event = Mousewheel.event();\r\n\r\n    if (swiper.params.cssMode) {\r\n      swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);\r\n      return true;\r\n    }\r\n\r\n    if (!event) return false;\r\n    if (swiper.mousewheel.enabled) return false;\r\n    var target = swiper.$el;\r\n\r\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\r\n      target = $(swiper.params.mousewheel.eventsTarget);\r\n    }\r\n\r\n    target.on('mouseenter', swiper.mousewheel.handleMouseEnter);\r\n    target.on('mouseleave', swiper.mousewheel.handleMouseLeave);\r\n    target.on(event, swiper.mousewheel.handle);\r\n    swiper.mousewheel.enabled = true;\r\n    return true;\r\n  },\r\n  disable: function disable() {\r\n    var swiper = this;\r\n    var event = Mousewheel.event();\r\n\r\n    if (swiper.params.cssMode) {\r\n      swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);\r\n      return true;\r\n    }\r\n\r\n    if (!event) return false;\r\n    if (!swiper.mousewheel.enabled) return false;\r\n    var target = swiper.$el;\r\n\r\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\r\n      target = $(swiper.params.mousewheel.eventsTarget);\r\n    }\r\n\r\n    target.off(event, swiper.mousewheel.handle);\r\n    swiper.mousewheel.enabled = false;\r\n    return true;\r\n  }\r\n};\r\nexport default {\r\n  name: 'mousewheel',\r\n  params: {\r\n    mousewheel: {\r\n      enabled: false,\r\n      releaseOnEdges: false,\r\n      invert: false,\r\n      forceToAxis: false,\r\n      sensitivity: 1,\r\n      eventsTarget: 'container',\r\n      thresholdDelta: null,\r\n      thresholdTime: null\r\n    }\r\n  },\r\n  create: function create() {\r\n    var swiper = this;\r\n    bindModuleMethods(swiper, {\r\n      mousewheel: {\r\n        enabled: false,\r\n        lastScrollTime: now(),\r\n        lastEventBeforeSnap: undefined,\r\n        recentWheelEvents: [],\r\n        enable: Mousewheel.enable,\r\n        disable: Mousewheel.disable,\r\n        handle: Mousewheel.handle,\r\n        handleMouseEnter: Mousewheel.handleMouseEnter,\r\n        handleMouseLeave: Mousewheel.handleMouseLeave,\r\n        animateSlider: Mousewheel.animateSlider,\r\n        releaseScroll: Mousewheel.releaseScroll\r\n      }\r\n    });\r\n  },\r\n  on: {\r\n    init: function init(swiper) {\r\n      if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\r\n        swiper.mousewheel.disable();\r\n      }\r\n\r\n      if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();\r\n    },\r\n    destroy: function destroy(swiper) {\r\n      if (swiper.params.cssMode) {\r\n        swiper.mousewheel.enable();\r\n      }\r\n\r\n      if (swiper.mousewheel.enabled) swiper.mousewheel.disable();\r\n    }\r\n  }\r\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}