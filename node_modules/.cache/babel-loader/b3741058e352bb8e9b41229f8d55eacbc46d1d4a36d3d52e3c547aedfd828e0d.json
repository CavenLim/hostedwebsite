{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nimport { useBoolean, useCallbackRef, useControllableState, useId, useLatestRef, usePanGesture, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { mergeRefs } from \"@chakra-ui/react-utils\";\nimport { ariaAttr, callAllHandlers, clampValue, dataAttr, focus, normalizeEventKey, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/utils\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { getIds, getIsReversed, getStyles, orient } from \"./slider-utils\";\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useRangeSlider(props) {\n  var {\n      min = 0,\n      max = 100,\n      onChange,\n      value: valueProp,\n      defaultValue,\n      isReversed: isReversedProp,\n      direction = \"ltr\",\n      orientation = \"horizontal\",\n      id: idProp,\n      isDisabled,\n      isReadOnly,\n      onChangeStart: onChangeStartProp,\n      onChangeEnd: onChangeEndProp,\n      step = 1,\n      getAriaValueText: getAriaValueTextProp,\n      \"aria-valuetext\": ariaValueText,\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabelledBy,\n      name,\n      focusThumbOnChange = true,\n      minStepsBetweenThumbs = 0\n    } = props,\n    htmlProps = _objectWithoutPropertiesLoose(props, [\"min\", \"max\", \"onChange\", \"value\", \"defaultValue\", \"isReversed\", \"direction\", \"orientation\", \"id\", \"isDisabled\", \"isReadOnly\", \"onChangeStart\", \"onChangeEnd\", \"step\", \"getAriaValueText\", \"aria-valuetext\", \"aria-label\", \"aria-labelledby\", \"name\", \"focusThumbOnChange\", \"minStepsBetweenThumbs\"]);\n  var onChangeStart = useCallbackRef(onChangeStartProp);\n  var onChangeEnd = useCallbackRef(onChangeEndProp);\n  var getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  var isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation\n  });\n  var [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : [25, 75],\n    onChange\n  });\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(\"[range-slider] You passed an invalid value for `value` or `defaultValue`, expected `Array` but got `\" + typeof valueState + \"`\");\n  }\n  var [isDragging, setDragging] = useBoolean();\n  var [isFocused, setFocused] = useBoolean();\n  var [activeIndex, setActiveIndex] = useState(-1);\n  var eventSourceRef = useRef(null);\n  var isInteractive = !(isDisabled || isReadOnly);\n  var initialValue = useRef(valueState);\n  var value = valueState.map(val => clampValue(val, min, max));\n  var valueRef = useLatestRef(value);\n  var spacing = minStepsBetweenThumbs * step;\n  var valueBounds = getValueBounds(value, min, max, spacing);\n  var reversedValue = value.map(val => max - val + min);\n  var thumbValues = isReversed ? reversedValue : value;\n  var thumbPercents = thumbValues.map(val => valueToPercent(val, min, max));\n  var isVertical = orientation === \"vertical\";\n  var [thumbRects, setThumbRects] = useState(Array.from({\n    length: value.length\n  }).map(() => ({\n    width: 0,\n    height: 0\n  })));\n  useEffect(() => {\n    var _rootRef$current;\n    if (!rootRef.current) return;\n    var thumbs = Array.from((_rootRef$current = rootRef.current) == null ? void 0 : _rootRef$current.querySelectorAll(\"[role=slider]\"));\n    var rects = thumbs.map(el => ({\n      width: el.offsetWidth,\n      height: el.offsetHeight\n    }));\n    if (rects.length) setThumbRects(rects);\n  }, []);\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n\n  var trackRef = useRef(null);\n  var rootRef = useRef(null);\n  var uuid = useId(idProp);\n  var ids = getIds(uuid);\n  var getValueFromPointer = useCallback(event => {\n    var _event$touches$, _event$touches;\n    if (!trackRef.current) return;\n    eventSourceRef.current = \"pointer\";\n    var rect = trackRef.current.getBoundingClientRect();\n    var {\n      clientX,\n      clientY\n    } = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event;\n    var diff = isVertical ? rect.bottom - clientY : clientX - rect.left;\n    var length = isVertical ? rect.height : rect.width;\n    var percent = diff / length;\n    if (isReversed) percent = 1 - percent;\n    return percentToValue(percent, min, max);\n  }, [isVertical, isReversed, max, min]);\n  var tenSteps = (max - min) / 10;\n  var oneStep = step || (max - min) / 100;\n  var actions = useMemo(() => ({\n    setValueAtIndex: (index, val) => {\n      if (!isInteractive) return;\n      var bounds = valueBounds[index];\n      val = parseFloat(roundValueToStep(val, bounds.min, oneStep));\n      val = clampValue(val, bounds.min, bounds.max);\n      var next = [...value];\n      next[index] = val;\n      setValue(next);\n    },\n    setActiveIndex,\n    stepUp: function stepUp(index, step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n      var valueAtIndex = value[index];\n      var next = isReversed ? valueAtIndex - step : valueAtIndex + step;\n      actions.setValueAtIndex(index, next);\n    },\n    stepDown: function stepDown(index, step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n      var valueAtIndex = value[index];\n      var next = isReversed ? valueAtIndex + step : valueAtIndex - step;\n      actions.setValueAtIndex(index, next);\n    },\n    reset: () => setValue(initialValue.current)\n  }), [oneStep, value, isReversed, setValue, isInteractive, valueBounds]);\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n\n  var onKeyDown = useCallback(event => {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: () => actions.stepUp(activeIndex),\n      ArrowUp: () => actions.stepUp(activeIndex),\n      ArrowLeft: () => actions.stepDown(activeIndex),\n      ArrowDown: () => actions.stepDown(activeIndex),\n      PageUp: () => actions.stepUp(activeIndex, tenSteps),\n      PageDown: () => actions.stepDown(activeIndex, tenSteps),\n      Home: () => {\n        var {\n          min: value\n        } = valueBounds[activeIndex];\n        actions.setValueAtIndex(activeIndex, value);\n      },\n      End: () => {\n        var {\n          max: value\n        } = valueBounds[activeIndex];\n        actions.setValueAtIndex(activeIndex, value);\n      }\n    };\n    var action = keyMap[eventKey];\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      eventSourceRef.current = \"keyboard\";\n    }\n  }, [actions, activeIndex, tenSteps, valueBounds]);\n  /**\n   * Compute styles for all component parts.\n   */\n\n  var {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle\n  } = useMemo(() => getStyles({\n    isReversed,\n    orientation,\n    thumbRects,\n    thumbPercents\n  }), [isReversed, orientation, thumbPercents, thumbRects]);\n  var focusThumb = useCallback(index => {\n    var idx = index != null ? index : activeIndex;\n    if (idx !== -1 && focusThumbOnChange) {\n      var _rootRef$current2;\n      var id = ids.getThumb(idx);\n      var thumb = (_rootRef$current2 = rootRef.current) == null ? void 0 : _rootRef$current2.ownerDocument.getElementById(id);\n      if (thumb) {\n        setTimeout(() => focus(thumb));\n      }\n    }\n  }, [focusThumbOnChange, activeIndex, ids]);\n  useUpdateEffect(() => {\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n    }\n  }, [value, onChangeEnd]);\n  var onPanSessionStart = event => {\n    var pointValue = getValueFromPointer(event) || 0;\n    var distances = value.map(val => Math.abs(val - pointValue));\n    var isThumbStacked = new Set(distances).size !== distances.length;\n    var closest = Math.min(...distances);\n    var index = distances.indexOf(closest); // when two thumbs are stacked and the user clicks at a point larger than\n    // their values, pick the next closest thumb\n\n    if (isThumbStacked && pointValue > value[index]) {\n      index++;\n    }\n    setActiveIndex(index);\n    actions.setValueAtIndex(index, pointValue);\n    focusThumb(index);\n  };\n  var onPan = event => {\n    var pointValue = getValueFromPointer(event) || 0;\n    setActiveIndex(activeIndex);\n    actions.setValueAtIndex(activeIndex, pointValue);\n    focusThumb(activeIndex);\n  };\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return;\n      setDragging.on();\n      onPanSessionStart(event);\n      onChangeStart == null ? void 0 : onChangeStart(valueRef.current);\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return;\n      setDragging.off();\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n    },\n    onPan(event) {\n      if (!isInteractive) return;\n      onPan(event);\n    }\n  });\n  var getRootProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, htmlProps, {\n      id: ids.root,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: _extends({}, props.style, rootStyle)\n    });\n  }, [htmlProps, isDisabled, isFocused, rootStyle, ids]);\n  var getTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref: mergeRefs(ref, trackRef),\n      id: ids.track,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: _extends({}, props.style, trackStyle)\n    });\n  }, [isDisabled, trackStyle, ids]);\n  var getInnerTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref,\n      id: ids.innerTrack,\n      style: _extends({}, props.style, innerTrackStyle)\n    });\n  }, [innerTrackStyle, ids]);\n  var getThumbProps = useCallback(function (props, ref) {\n    var _getAriaValueText;\n    if (ref === void 0) {\n      ref = null;\n    }\n    var {\n        index\n      } = props,\n      rest = _objectWithoutPropertiesLoose(props, [\"index\"]);\n    var _value = value[index];\n    if (_value == null) {\n      throw new TypeError(\"[range-slider > thumb] Cannot find value at index `\" + index + \"`. The `value` or `defaultValue` length is : \" + value.length);\n    }\n    var bounds = valueBounds[index];\n    return _extends({}, rest, {\n      ref,\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: ids.getThumb(index),\n      \"data-active\": dataAttr(isDragging && activeIndex === index),\n      \"aria-valuetext\": (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(_value)) != null ? _getAriaValueText : ariaValueText == null ? void 0 : ariaValueText[index],\n      \"aria-valuemin\": bounds.min,\n      \"aria-valuemax\": bounds.max,\n      \"aria-valuenow\": _value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel == null ? void 0 : ariaLabel[index],\n      \"aria-labelledby\": ariaLabel != null && ariaLabel[index] ? undefined : ariaLabelledBy == null ? void 0 : ariaLabelledBy[index],\n      style: _extends({}, props.style, getThumbStyle(index)),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, () => {\n        setFocused.on();\n        setActiveIndex(index);\n      }),\n      onBlur: callAllHandlers(props.onBlur, () => {\n        setFocused.off();\n        setActiveIndex(-1);\n      })\n    });\n  }, [ids, value, valueBounds, isInteractive, isDragging, activeIndex, getAriaValueText, ariaValueText, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused]);\n  var getOutputProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    return _extends({}, props, {\n      ref,\n      id: ids.output,\n      htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n      \"aria-live\": \"off\"\n    });\n  }, [ids, value]);\n  var getMarkerProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n    if (ref === void 0) {\n      ref = null;\n    }\n    var {\n        value: v\n      } = props,\n      rest = _objectWithoutPropertiesLoose(props, [\"value\"]);\n    var isInRange = !(v < min || v > max);\n    var isHighlighted = v >= value[0] && v <= value[value.length - 1];\n    var percent = valueToPercent(v, min, max);\n    percent = isReversed ? 100 - percent : percent;\n    var markerStyle = _extends({\n      position: \"absolute\",\n      pointerEvents: \"none\"\n    }, orient({\n      orientation,\n      vertical: {\n        bottom: percent + \"%\"\n      },\n      horizontal: {\n        left: percent + \"%\"\n      }\n    }));\n    return _extends({}, rest, {\n      ref,\n      id: ids.getMarker(props.value),\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: _extends({}, props.style, markerStyle)\n    });\n  }, [isDisabled, isReversed, max, min, orientation, value, ids]);\n  var getInputProps = useCallback(function (props, ref) {\n    if (ref === void 0) {\n      ref = null;\n    }\n    var {\n        index\n      } = props,\n      rest = _objectWithoutPropertiesLoose(props, [\"index\"]);\n    return _extends({}, rest, {\n      ref,\n      id: ids.getInput(index),\n      type: \"hidden\",\n      value: value[index],\n      name: Array.isArray(name) ? name[index] : name + \"-\" + index\n    });\n  }, [name, value, ids]);\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n      getThumbPercent: i => thumbPercents[i],\n      getThumbMinValue: i => valueBounds[i].min,\n      getThumbMaxValue: i => valueBounds[i].max\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps\n  };\n}\nvar getValueBounds = (arr, min, max, spacing) => arr.map((v, i) => {\n  var _min = i === 0 ? min : arr[i - 1] + spacing;\n  var _max = i === arr.length - 1 ? max : arr[i + 1] - spacing;\n  return {\n    min: _min,\n    max: _max\n  };\n});","map":{"version":3,"names":["useBoolean","useCallbackRef","useControllableState","useId","useLatestRef","usePanGesture","useUpdateEffect","mergeRefs","ariaAttr","callAllHandlers","clampValue","dataAttr","focus","normalizeEventKey","percentToValue","roundValueToStep","valueToPercent","useCallback","useEffect","useMemo","useRef","useState","getIds","getIsReversed","getStyles","orient","useRangeSlider","props","min","max","onChange","value","valueProp","defaultValue","isReversed","isReversedProp","direction","orientation","id","idProp","isDisabled","isReadOnly","onChangeStart","onChangeStartProp","onChangeEnd","onChangeEndProp","step","getAriaValueText","getAriaValueTextProp","ariaValueText","ariaLabel","ariaLabelledBy","name","focusThumbOnChange","minStepsBetweenThumbs","htmlProps","_objectWithoutPropertiesLoose","valueState","setValue","Array","isArray","TypeError","isDragging","setDragging","isFocused","setFocused","activeIndex","setActiveIndex","eventSourceRef","isInteractive","initialValue","map","val","valueRef","spacing","valueBounds","getValueBounds","reversedValue","thumbValues","thumbPercents","isVertical","thumbRects","setThumbRects","from","length","width","height","_rootRef$current","rootRef","current","thumbs","querySelectorAll","rects","el","offsetWidth","offsetHeight","trackRef","uuid","ids","getValueFromPointer","event","_event$touches$","_event$touches","rect","getBoundingClientRect","clientX","clientY","touches","diff","bottom","left","percent","tenSteps","oneStep","actions","setValueAtIndex","index","bounds","parseFloat","next","stepUp","valueAtIndex","stepDown","reset","onKeyDown","eventKey","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","preventDefault","stopPropagation","getThumbStyle","rootStyle","trackStyle","innerTrackStyle","focusThumb","idx","_rootRef$current2","getThumb","thumb","ownerDocument","getElementById","setTimeout","onPanSessionStart","pointValue","distances","Math","abs","isThumbStacked","Set","size","closest","indexOf","onPan","on","onPanSessionEnd","off","getRootProps","ref","_extends","root","tabIndex","style","getTrackProps","track","getInnerTrackProps","innerTrack","getThumbProps","_getAriaValueText","rest","_value","role","undefined","onFocus","onBlur","getOutputProps","output","htmlFor","v","i","join","getMarkerProps","isInRange","isHighlighted","markerStyle","position","pointerEvents","vertical","horizontal","getMarker","getInputProps","getInput","type","state","getThumbPercent","getThumbMinValue","getThumbMaxValue","arr","_min","_max"],"sources":["/Users/cavenlim/CavenLim site backup/node_modules/@chakra-ui/slider/src/use-range-slider.ts"],"sourcesContent":["import {\n  useBoolean,\n  useCallbackRef,\n  useControllableState,\n  useId,\n  useLatestRef,\n  usePanGesture,\n  useUpdateEffect,\n} from \"@chakra-ui/hooks\"\nimport { EventKeyMap, mergeRefs, PropGetter } from \"@chakra-ui/react-utils\"\nimport {\n  AnyPointerEvent,\n  ariaAttr,\n  callAllHandlers,\n  clampValue,\n  dataAttr,\n  focus,\n  normalizeEventKey,\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/utils\"\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\nimport { getIds, getIsReversed, getStyles, orient } from \"./slider-utils\"\n\nexport interface UseRangeSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number[]\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number[]\n  /**\n   * orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number[]): void\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number[]): void\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number[]): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string | string[]\n  /**\n   * If `true`, the slider will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string[]\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string[]\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string[]\n  /**\n   * The writing mode\n   */\n  direction?: \"ltr\" | \"rtl\"\n  /**\n   * The minimum distance between slider thumbs. Useful for preventing\n   * the thumbs from being too close together.\n   * @default 0\n   */\n  minStepsBetweenThumbs?: number\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useRangeSlider(props: UseRangeSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    minStepsBetweenThumbs = 0,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  const [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? [25, 75],\n    onChange,\n  })\n\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(\n      `[range-slider] You passed an invalid value for \\`value\\` or \\`defaultValue\\`, expected \\`Array\\` but got \\`${typeof valueState}\\``,\n    )\n  }\n\n  const [isDragging, setDragging] = useBoolean()\n  const [isFocused, setFocused] = useBoolean()\n  const [activeIndex, setActiveIndex] = useState(-1)\n  const eventSourceRef = useRef<\"pointer\" | \"keyboard\" | null>(null)\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  const initialValue = useRef(valueState)\n  const value = valueState.map((val) => clampValue(val, min, max))\n  const valueRef = useLatestRef(value)\n\n  const spacing = minStepsBetweenThumbs * step\n  const valueBounds = getValueBounds(value, min, max, spacing)\n\n  const reversedValue = value.map((val) => max - val + min)\n  const thumbValues = isReversed ? reversedValue : value\n\n  const thumbPercents = thumbValues.map((val) => valueToPercent(val, min, max))\n\n  const isVertical = orientation === \"vertical\"\n\n  const [thumbRects, setThumbRects] = useState(\n    Array.from({ length: value.length }).map(() => ({ width: 0, height: 0 })),\n  )\n\n  useEffect(() => {\n    if (!rootRef.current) return\n\n    const thumbs = Array.from(\n      rootRef.current?.querySelectorAll<HTMLElement>(\"[role=slider]\"),\n    )\n    const rects = thumbs.map((el) => ({\n      width: el.offsetWidth,\n      height: el.offsetHeight,\n    }))\n\n    if (rects.length) setThumbRects(rects)\n  }, [])\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<HTMLElement>(null)\n  const rootRef = useRef<HTMLElement>(null)\n\n  const uuid = useId(idProp)\n  const ids = getIds(uuid)\n\n  const getValueFromPointer = useCallback(\n    (event) => {\n      if (!trackRef.current) return\n      eventSourceRef.current = \"pointer\"\n      const rect = trackRef.current.getBoundingClientRect()\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical ? rect.bottom - clientY : clientX - rect.left\n      const length = isVertical ? rect.height : rect.width\n\n      let percent = diff / length\n      if (isReversed) percent = 1 - percent\n\n      return percentToValue(percent, min, max)\n    },\n    [isVertical, isReversed, max, min],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const actions = useMemo(\n    () => ({\n      setValueAtIndex: (index: number, val: number) => {\n        if (!isInteractive) return\n        const bounds = valueBounds[index]\n        val = parseFloat(roundValueToStep(val, bounds.min, oneStep))\n        val = clampValue(val, bounds.min, bounds.max)\n        const next = [...value]\n        next[index] = val\n        setValue(next)\n      },\n      setActiveIndex,\n      stepUp: (index: number, step = oneStep) => {\n        const valueAtIndex = value[index]\n        const next = isReversed ? valueAtIndex - step : valueAtIndex + step\n        actions.setValueAtIndex(index, next)\n      },\n      stepDown: (index: number, step = oneStep) => {\n        const valueAtIndex = value[index]\n        const next = isReversed ? valueAtIndex + step : valueAtIndex - step\n        actions.setValueAtIndex(index, next)\n      },\n      reset: () => setValue(initialValue.current),\n    }),\n    [oneStep, value, isReversed, setValue, isInteractive, valueBounds],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => actions.stepUp(activeIndex),\n        ArrowUp: () => actions.stepUp(activeIndex),\n        ArrowLeft: () => actions.stepDown(activeIndex),\n        ArrowDown: () => actions.stepDown(activeIndex),\n        PageUp: () => actions.stepUp(activeIndex, tenSteps),\n        PageDown: () => actions.stepDown(activeIndex, tenSteps),\n        Home: () => {\n          const { min: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n        End: () => {\n          const { max: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        eventSourceRef.current = \"keyboard\"\n      }\n    },\n    [actions, activeIndex, tenSteps, valueBounds],\n  )\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = useMemo(\n    () =>\n      getStyles({\n        isReversed,\n        orientation,\n        thumbRects,\n        thumbPercents,\n      }),\n    [isReversed, orientation, thumbPercents, thumbRects],\n  )\n\n  const focusThumb = useCallback(\n    (index?: number) => {\n      const idx = index ?? activeIndex\n      if (idx !== -1 && focusThumbOnChange) {\n        const id = ids.getThumb(idx)\n        const thumb = rootRef.current?.ownerDocument.getElementById(id)\n        if (thumb) {\n          setTimeout(() => focus(thumb))\n        }\n      }\n    },\n    [focusThumbOnChange, activeIndex, ids],\n  )\n\n  useUpdateEffect(() => {\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd?.(valueRef.current)\n    }\n  }, [value, onChangeEnd])\n\n  const onPanSessionStart = (event: AnyPointerEvent) => {\n    const pointValue = getValueFromPointer(event) || 0\n    const distances = value.map((val) => Math.abs(val - pointValue))\n    const isThumbStacked = new Set(distances).size !== distances.length\n    const closest = Math.min(...distances)\n    let index = distances.indexOf(closest)\n    // when two thumbs are stacked and the user clicks at a point larger than\n    // their values, pick the next closest thumb\n    if (isThumbStacked && pointValue > value[index]) {\n      index++\n    }\n    setActiveIndex(index)\n    actions.setValueAtIndex(index, pointValue)\n    focusThumb(index)\n  }\n\n  const onPan = (event: AnyPointerEvent) => {\n    const pointValue = getValueFromPointer(event) || 0\n    setActiveIndex(activeIndex)\n    actions.setValueAtIndex(activeIndex, pointValue)\n    focusThumb(activeIndex)\n  }\n\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging.on()\n      onPanSessionStart(event)\n      onChangeStart?.(valueRef.current)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging.off()\n      onChangeEnd?.(valueRef.current)\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      onPan(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ...htmlProps,\n      id: ids.root,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: { ...props.style, ...rootStyle },\n    }),\n    [htmlProps, isDisabled, isFocused, rootStyle, ids],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, trackRef),\n      id: ids.track,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: { ...props.style, ...trackStyle },\n    }),\n    [isDisabled, trackStyle, ids],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      id: ids.innerTrack,\n      style: { ...props.style, ...innerTrackStyle },\n    }),\n    [innerTrackStyle, ids],\n  )\n\n  const getThumbProps = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n\n      const _value = value[index]\n      if (_value == null) {\n        throw new TypeError(\n          `[range-slider > thumb] Cannot find value at index \\`${index}\\`. The \\`value\\` or \\`defaultValue\\` length is : ${value.length}`,\n        )\n      }\n      const bounds = valueBounds[index]\n\n      return {\n        ...rest,\n        ref,\n        role: \"slider\",\n        tabIndex: isInteractive ? 0 : undefined,\n        id: ids.getThumb(index),\n        \"data-active\": dataAttr(isDragging && activeIndex === index),\n        \"aria-valuetext\": getAriaValueText?.(_value) ?? ariaValueText?.[index],\n        \"aria-valuemin\": bounds.min,\n        \"aria-valuemax\": bounds.max,\n        \"aria-valuenow\": _value,\n        \"aria-orientation\": orientation,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"aria-readonly\": ariaAttr(isReadOnly),\n        \"aria-label\": ariaLabel?.[index],\n        \"aria-labelledby\": ariaLabel?.[index]\n          ? undefined\n          : ariaLabelledBy?.[index],\n        style: { ...props.style, ...getThumbStyle(index) },\n        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(props.onFocus, () => {\n          setFocused.on()\n          setActiveIndex(index)\n        }),\n        onBlur: callAllHandlers(props.onBlur, () => {\n          setFocused.off()\n          setActiveIndex(-1)\n        }),\n      }\n    },\n    [\n      ids,\n      value,\n      valueBounds,\n      isInteractive,\n      isDragging,\n      activeIndex,\n      getAriaValueText,\n      ariaValueText,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n      setFocused,\n    ],\n  )\n\n  const getOutputProps = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      id: ids.output,\n      htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n      \"aria-live\": \"off\",\n    }),\n    [ids, value],\n  )\n\n  const getMarkerProps: PropGetter<any, { value?: any }> = useCallback(\n    (props = {}, ref = null) => {\n      const { value: v, ...rest } = props\n\n      const isInRange = !(v < min || v > max)\n      const isHighlighted = v >= value[0] && v <= value[value.length - 1]\n\n      let percent = valueToPercent(v, min, max)\n      percent = isReversed ? 100 - percent : percent\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: { bottom: `${percent}%` },\n          horizontal: { left: `${percent}%` },\n        }),\n      }\n\n      return {\n        ...rest,\n        ref,\n        id: ids.getMarker(props.value),\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value, ids],\n  )\n\n  const getInputProps = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n      return {\n        ...rest,\n        ref,\n        id: ids.getInput(index),\n        type: \"hidden\",\n        value: value[index],\n        name: Array.isArray(name) ? name[index] : `${name}-${index}`,\n      }\n    },\n    [name, value, ids],\n  )\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n      getThumbPercent: (i: number) => thumbPercents[i],\n      getThumbMinValue: (i: number) => valueBounds[i].min,\n      getThumbMaxValue: (i: number) => valueBounds[i].max,\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps,\n  }\n}\n\nexport type UseRangeSliderReturn = ReturnType<typeof useRangeSlider>\n\nconst getValueBounds = (\n  arr: number[],\n  min: number,\n  max: number,\n  spacing: number,\n) =>\n  arr.map((v, i) => {\n    const _min = i === 0 ? min : arr[i - 1] + spacing\n    const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing\n    return { min: _min, max: _max }\n  })\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}